# ***************图着色问题******************
Node = ['A', 'B', 'C', 'D', 'E']

# 无向图邻接矩阵
Graph = [
    [0, 1, 1, 0, 0],
    [1, 0, 1, 1, 1],
    [1, 1, 0, 0, 1],
    [0, 1, 0, 0, 1],
    [0, 1, 1, 1, 0]
]

# 着色结果数组
Result = [0 for i in range(len(Graph))]


# 检验颜色是否冲突
def isConflict(k):
    for i in range(k):
        # 如果颜色号相等 -> 颜色冲突
        if Graph[i][k] * Result[k] == Result[i]:
            return True
    return False


def get_color_num(m):
    # 标志位:检验着色是否成功
    flag = False

    # 设从第0个节点开始遍历
    node_id = 0
    while node_id >= 0 and not flag:
        # 着色号 < m
        while Result[node_id] < m:
            Result[node_id] += 1
            # 检验当前节点与其他连接的节点颜色是否冲突
            if not isConflict(node_id):
                if node_id == len(Graph) - 1:
                    flag = True
                    break
                node_id += 1
                Result[node_id] = 0
        # 回溯
        node_id -= 1
    return flag


if __name__ == "__main__":
    # 设初始可用颜色数量为１
    m = 1
    while not get_color_num(m):
        # 可用颜色数量+1
        m += 1
        Result = [0 for i in range(len(Graph))]

    print(f"最少需要的颜色数量为:{m}")
    print(f"每个顶点对应的颜色号为:", end="")
    for i in range(len(Node)):
        print(f"{Node[i]}:{Result[i]}, ", end="")

# 深度优先遍历:
# 使用栈的方式实现:
# 栈存放遍历过的路径节点,每当根据判断条件发现此路径无法向下遍历时, 则弹栈, 回到上一节点, 然后进入到上一节点的节点的另外一个分支,继续遍历.
# 使用递归的方式实现:
# 每一次递归为遍历一个节点，当根据判断条件发现无法向下嵌套函数时, 则退回到上一个函数, 然后进入到上一个函数的的另外一个递归.

# 如果遍历的目的是从所有结果中取出以最好的结果，那么就采用递归的方式遍历所有路径。找到最好结果,例如01背包问题，
# 如果遍历的目的是找到一条可能存在的路径，符合要求的可能存在,也可能不存在, 那么就采用栈的方式去遍历.例如图着色问题,拿颜色数量m去试;可能着色成功,也可能不成功, 求解迷宫问题,可能找到到达终点的路径,也可能找不到

# 如果路径分支较少, 则可以列出分支,依次进入,例如:01背包问题, 有装入物品和不装入物品两种选择. 两种选择可列出
# 如果路径分支较多, 则可以使用循环的的方式依次进入, 例如:图着色问题. 可以选择多种颜色, 有多个选择不可列出.

# 回溯法是在深度优先遍历的基础之上添加一些限制条件, 是深度优先搜索（DFS）的一种,这是一种思想
# 回溯法通俗的将其采用的思想是“一直向下走，走不通就掉头”，类似于树的先序遍历。dfs和回溯法其主要的区别是：回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。
# 为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种处理方法使得深度优先搜索法与回溯法没什么区别了。